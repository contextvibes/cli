package config

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/contextvibes/cli/internal/exec" // Import the new exec client
	"gopkg.in/yaml.v3"
)

const (
	// DefaultConfigFileName is the default name for the contextvibes configuration file.
	DefaultConfigFileName = ".contextvibes.yaml"

	// DefaultCodemodFilename is the default name for the codemod script JSON file.
	// To align with README and cmd/codemod.go, this should be "codemod.json"
	// For now, keeping as per your existing file to focus on the commit regex.
	// DefaultCodemodFilename = "contextvibes-codemod.json" // Previous value
	DefaultCodemodFilename = "codemod.json" // Aligning with cmd/codemod.go and README

	// DefaultDescribeOutputFile is the default name for the file generated by 'describe' and 'diff'.
	DefaultDescribeOutputFile = "contextvibes.md"

	// DefaultBranchNamePattern is the default regex for validating branch names.
	DefaultBranchNamePattern = `^((feature|fix|docs|format)/.+)$`

	// DefaultCommitMessagePattern is the default regex for validating commit messages.
	// MODIFIED HERE TO ALLOW '/' IN SCOPE
	DefaultCommitMessagePattern = `^(BREAKING|feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)(\([a-zA-Z0-9\-_/]+\))?:\s.+`

	// DefaultGitRemote is the default Git remote name.
	DefaultGitRemote = "origin"
	// DefaultGitMainBranch is the default Git main branch name.
	DefaultGitMainBranch = "main"
	// UltimateDefaultAILogFilename is the fallback name for the AI trace log file.
	// To align with README and common usage: "contextvibes_ai_trace.log"
	// For now, keeping as per your existing file to focus on the commit regex.
	// UltimateDefaultAILogFilename = "contextvibes.log" // Previous value
	UltimateDefaultAILogFilename = "contextvibes_ai_trace.log" // Aligning with README

)

type GitSettings struct {
	DefaultRemote     string `yaml:"defaultRemote,omitempty"`
	DefaultMainBranch string `yaml:"defaultMainBranch,omitempty"`
}

type ValidationRule struct {
	Enable  *bool  `yaml:"enable,omitempty"` // Pointer to bool to distinguish between false and not set
	Pattern string `yaml:"pattern,omitempty"`
}

type LoggingSettings struct {
	DefaultAILogFile string `yaml:"defaultAILogFile,omitempty"`
}

type Config struct {
	Git        GitSettings     `yaml:"git,omitempty"`
	Logging    LoggingSettings `yaml:"logging,omitempty"`
	Validation struct {
		BranchName    ValidationRule `yaml:"branchName,omitempty"`
		CommitMessage ValidationRule `yaml:"commitMessage,omitempty"`
	} `yaml:"validation,omitempty"`
}

func GetDefaultConfig() *Config {
	enableTrue := true // Helper to get a pointer to true
	return &Config{
		Git: GitSettings{
			DefaultRemote:     DefaultGitRemote,
			DefaultMainBranch: DefaultGitMainBranch,
		},
		Logging: LoggingSettings{
			DefaultAILogFile: UltimateDefaultAILogFilename,
		},
		Validation: struct {
			BranchName    ValidationRule `yaml:"branchName,omitempty"`
			CommitMessage ValidationRule `yaml:"commitMessage,omitempty"`
		}{
			BranchName: ValidationRule{
				Enable:  &enableTrue,
				Pattern: DefaultBranchNamePattern,
			},
			CommitMessage: ValidationRule{
				Enable:  &enableTrue,
				Pattern: DefaultCommitMessagePattern, // Uses the updated pattern
			},
		},
	}
}

func LoadConfig(filePath string) (*Config, error) {
	if _, err := os.Stat(filePath); os.IsNotExist(err) {
		// Return nil, nil if the file simply doesn't exist, indicating no user config.
		return nil, nil
	}
	data, err := os.ReadFile(filePath)
	if err != nil {
		return nil, fmt.Errorf("failed to read config file '%s': %w", filePath, err)
	}
	var cfg Config
	err = yaml.Unmarshal(data, &cfg)
	if err != nil {
		return nil, fmt.Errorf("failed to parse config file '%s': %w", filePath, err)
	}
	return &cfg, nil
}

// FindRepoRootConfigPath now takes an ExecutorClient to find the repo root.
func FindRepoRootConfigPath(execClient *exec.ExecutorClient) (string, error) {
	if execClient == nil {
		return "", fmt.Errorf("executor client is nil, cannot find repo root")
	}
	ctx := context.Background()
	stdout, stderr, err := execClient.CaptureOutput(ctx, ".", "git", "rev-parse", "--show-toplevel")
	if err != nil {
		return "", fmt.Errorf("failed to determine git repository root (is this a git repo, or is 'git' not in PATH? details: %s): %w", strings.TrimSpace(stderr), err)
	}
	repoRoot := filepath.Clean(strings.TrimSpace(stdout))
	if repoRoot == "" || repoRoot == "." {
		return "", fmt.Errorf("git rev-parse --show-toplevel returned an empty or invalid path: '%s'", repoRoot)
	}

	configPath := filepath.Join(repoRoot, DefaultConfigFileName) // Uses the constant
	if _, statErr := os.Stat(configPath); os.IsNotExist(statErr) {
		return "", nil // Config file not found at the discovered root path, not an error for this func
	} else if statErr != nil {
		return "", fmt.Errorf("error checking for config file at '%s': %w", configPath, statErr)
	}

	return configPath, nil
}

func MergeWithDefaults(loadedCfg *Config, defaultConfig *Config) *Config {
	if loadedCfg == nil {
		return defaultConfig
	}
	finalCfg := *defaultConfig // Start with a copy of defaults

	// Git settings
	if loadedCfg.Git.DefaultRemote != "" {
		finalCfg.Git.DefaultRemote = loadedCfg.Git.DefaultRemote
	}
	if loadedCfg.Git.DefaultMainBranch != "" {
		finalCfg.Git.DefaultMainBranch = loadedCfg.Git.DefaultMainBranch
	}

	// Logging settings
	if loadedCfg.Logging.DefaultAILogFile != "" {
		finalCfg.Logging.DefaultAILogFile = loadedCfg.Logging.DefaultAILogFile
	}

	// Validation - BranchName
	if loadedCfg.Validation.BranchName.Enable != nil {
		finalCfg.Validation.BranchName.Enable = loadedCfg.Validation.BranchName.Enable
	}
	// If validation is enabled (either by user or by default if user didn't specify enable),
	// then consider user's pattern.
	if finalCfg.Validation.BranchName.Enable == nil || *finalCfg.Validation.BranchName.Enable {
		if loadedCfg.Validation.BranchName.Pattern != "" {
			finalCfg.Validation.BranchName.Pattern = loadedCfg.Validation.BranchName.Pattern
		}
		// If user pattern is empty, finalCfg.Validation.BranchName.Pattern already holds the default.
	} else { // Validation explicitly disabled by user
		finalCfg.Validation.BranchName.Pattern = "" // Clear pattern if disabled
	}

	// Validation - CommitMessage
	if loadedCfg.Validation.CommitMessage.Enable != nil {
		finalCfg.Validation.CommitMessage.Enable = loadedCfg.Validation.CommitMessage.Enable
	}
	if finalCfg.Validation.CommitMessage.Enable == nil || *finalCfg.Validation.CommitMessage.Enable {
		if loadedCfg.Validation.CommitMessage.Pattern != "" {
			finalCfg.Validation.CommitMessage.Pattern = loadedCfg.Validation.CommitMessage.Pattern
		}
		// If user pattern is empty, finalCfg.Validation.CommitMessage.Pattern already holds the default.
	} else { // Validation explicitly disabled by user
		finalCfg.Validation.CommitMessage.Pattern = "" // Clear pattern if disabled
	}

	return &finalCfg
}
