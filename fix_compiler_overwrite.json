{
    "description": "Fixes compiler errors by overwriting 'internal/contextgen/helpers.go' and 'cmd/context.go' with their complete, correct contents.",
    "steps": [
      {
        "type": "file_modification",
        "description": "Overwrite 'internal/contextgen/helpers.go' to fix syntax errors and ensure correct gosec pragmas.",
        "changes": [
          {
            "file_path": "internal/contextgen/helpers.go",
            "operations": [
              {
                "type": "create_or_overwrite",
                "content": "package contextgen\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/contextvibes/cli/internal/exec\"\n)\n\nfunc GenerateReportHeader(promptFile, defaultTitle string) (string, error) {\n\tsearchPaths := []string{\n\t\tfilepath.Join(\"docs\", \"prompts\", promptFile),\n\t\tfilepath.Join(\"..\", \"thea\", \"building-blocks\", \"prompts\", promptFile),\n\t}\n\tfor _, path := range searchPaths {\n\t\tif _, err := os.Stat(path); err == nil {\n\t\t\t//gosec:G304\n\t\t\tcontent, readErr := os.ReadFile(path)\n\t\t\tif readErr != nil {\n\t\t\t\treturn \"\", fmt.Errorf(\"failed to read prompt file %s: %w\", path, readErr)\n\t\t\t}\n\t\t\treturn string(content), nil\n\t\t}\n\t}\n\treturn fmt.Sprintf(\"# AI Prompt: %s\\n\\n---\\n\", defaultTitle), nil\n}\n\nfunc ExportBook(ctx context.Context, execClient *exec.ExecutorClient, outputFile, title string, paths ...string) (err error) {\n\t//gosec:G304\n\tf, err := os.OpenFile(outputFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0600)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to open output file: %w\", err)\n\t}\n\tdefer func() {\n\t\tif closeErr := f.Close(); closeErr != nil && err == nil {\n\t\t\terr = fmt.Errorf(\"failed to close output file: %w\", closeErr)\n\t\t}\n\t}()\n\n\tif _, err := fmt.Fprintf(f, \"\\n---\\n## Book: %s\\n\\n\", title); err != nil {\n\t\treturn fmt.Errorf(\"failed to write book header: %w\", err)\n\t}\n\tgitArgs := append([]string{\"ls-files\", \"--\"}, paths...)\n\tgitFilesBytes, _, err := execClient.CaptureOutput(ctx, \".\", \"git\", gitArgs...)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to list git files: %w\", err)\n\t}\n\tfor _, file := range strings.Split(gitFilesBytes, \"\\n\") {\n\t\tif file == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\t//gosec:G304\n\t\tcontent, err := os.ReadFile(file)\n\t\tif err != nil {\n\t\t\tif os.IsNotExist(err) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"failed to read file %s: %w\", file, err)\n\t\t}\n\t\text := filepath.Ext(file)\n\t\tlang := strings.TrimPrefix(ext, \".\")\n\t\tvar sb strings.Builder\n\t\tsb.WriteString(fmt.Sprintf(\"======== FILE: %s ========\\n\", file))\n\t\tsb.WriteString(\"```\" + lang + \"\\n\")\n\t\tsb.Write(content)\n\t\tsb.WriteString(\"\\n```\\n\")\n\t\tsb.WriteString(fmt.Sprintf(\"======== END FILE: %s ========\\n\\n\", file))\n\t\tif _, err := f.WriteString(sb.String()); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to write content for file %s: %w\", file, err)\n\t\t}\n\t}\n\treturn nil\n}\n"
              }
            ]
          }
        ]
      },
      {
        "type": "file_modification",
        "description": "Overwrite 'cmd/context.go' to ensure it has the correct imports and logic.",
        "changes": [
          {
            "file_path": "cmd/context.go",
            "operations": [
              {
                "type": "create_or_overwrite",
                "content": "package cmd\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/contextvibes/cli/internal/contextgen\"\n\t\"github.com/contextvibes/cli/internal/git\"\n\t\"github.com/contextvibes/cli/internal/ui\"\n\t\"github.com/spf13/cobra\"\n)\n\nvar contextCmd = &cobra.Command{\n\tUse:   \"context\",\n\tShort: \"Generates context for various development goals.\",\n}\n\nvar generateCommitCmd = &cobra.Command{\n\tUse:   \"generate-commit\",\n\tShort: \"Generates context for a commit message.\",\n\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\tpresenter := ui.NewPresenter(os.Stdout, os.Stderr, os.Stdin)\n\t\treturn runGenerateCommitContext(cmd.Context(), presenter)\n\t},\n}\n\nvar generatePrCmd = &cobra.Command{\n\tUse:   \"generate-pr\",\n\tShort: \"Generates context for a Pull Request description.\",\n\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\tpresenter := ui.NewPresenter(os.Stdout, os.Stderr, os.Stdin)\n\t\treturn runGeneratePrContext(cmd.Context(), presenter)\n\t},\n}\n\nvar exportCmd = &cobra.Command{\n\tUse:   \"export\",\n\tShort: \"Exports large-scale project context for AI onboarding.\",\n}\n\nvar exportAllCmd = &cobra.Command{\n\tUse:   \"all\",\n\tShort: \"Exports a comprehensive snapshot of the entire project.\",\n\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\tpresenter := ui.NewPresenter(os.Stdout, os.Stderr, os.Stdin)\n\t\toutputFile := \"context_export_project.md\"\n\t\tpresenter.Summary(\"Exporting full project context to %s...\", outputFile)\n\t\theader, err := contextgen.GenerateReportHeader(\"export-project-context.md\", \"Full Project Context\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := os.WriteFile(outputFile, []byte(header), 0600); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := contextgen.ExportBook(cmd.Context(), ExecClient, outputFile, \"Project Files\", \".\"); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpresenter.Success(\"Full project export complete.\")\n\t\treturn nil\n\t},\n}\n\nfunc runGenerateCommitContext(ctx context.Context, presenter *ui.Presenter) error {\n\tpresenter.Summary(\"Generating context for commit message...\")\n\theader, err := contextgen.GenerateReportHeader(\"generate-commit-message.md\", \"Generate Conventional Commit Command\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tstatus, _, err := ExecClient.CaptureOutput(ctx, \".\", \"git\", \"status\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tstagedDiff, _, err := ExecClient.CaptureOutput(ctx, \".\", \"git\", \"diff\", \"--staged\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tunstagedDiff, _, err := ExecClient.CaptureOutput(ctx, \".\", \"git\", \"diff\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tvar sb strings.Builder\n\tsb.WriteString(header)\n\tsb.WriteString(\"\\n## Git Status\\n```\\n\" + status + \"\\n```\\n\")\n\tsb.WriteString(\"---\\n## Diff of All Uncommitted Changes\\n```diff\\n\" + stagedDiff + unstagedDiff + \"\\n```\\n\")\n\treturn os.WriteFile(\"context_commit.md\", []byte(sb.String()), 0600)\n}\n\nfunc runGeneratePrContext(ctx context.Context, presenter *ui.Presenter) error {\n\tpresenter.Summary(\"Generating context for Pull Request description...\")\n\theader, err := contextgen.GenerateReportHeader(\"generate-pr-description.md\", \"Generate Pull Request Description\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tgitClient, err := git.NewClient(ctx, \".\", git.GitClientConfig{Logger: AppLogger, Executor: ExecClient.UnderlyingExecutor()})\n\tif err != nil {\n\t\treturn err\n\t}\n\tmainBranchRef := \"origin/\" + gitClient.MainBranchName()\n\tpresenter.Step(\"Fetching latest updates from remote...\")\n\t_ = ExecClient.Execute(ctx, \".\", \"git\", \"fetch\", \"origin\")\n\tlog, diff, err := gitClient.GetLogAndDiffFromMergeBase(ctx, mainBranchRef)\n\tif err != nil {\n\t\treturn err\n\t}\n\tvar sb strings.Builder\n\tsb.WriteString(header)\n\tsb.WriteString(fmt.Sprintf(\"\\n## Commit History on This Branch\\n```\\n%s\\n```\\n\", log))\n\tsb.WriteString(fmt.Sprintf(\"---\\n## Full Diff for Branch (vs. %s)\\n```diff\\n%s\\n```\\n\", mainBranchRef, diff))\n\treturn os.WriteFile(\"context_pr.md\", []byte(sb.String()), 0600)\n}\n\nfunc init() {\n\trootCmd.AddCommand(contextCmd)\n\tcontextCmd.AddCommand(generateCommitCmd)\n\tcontextCmd.AddCommand(generatePrCmd)\n\tcontextCmd.AddCommand(exportCmd)\n\texportCmd.AddCommand(exportAllCmd)\n}\n"
              }
            ]
          }
        ]
      },
      {
        "type": "command_execution",
        "description": "Run 'go mod tidy' to ensure all dependencies are clean.",
        "command": "go",
        "args": [
          "mod",
          "tidy"
        ]
      }
    ]
  }